#!/usr/bin/env perl 
#  W5Base Framework W5Replicate - object mirroring tool
#  Copyright (C) 2011  Hartmut Vogler (it@guru.de)
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
use FindBin;
use lib "$FindBin::Bin/../lib";
use lib "$FindBin::Bin/../mod";
use RPC::Smart::Client;
use strict;
use kernel;
use kernel::config;
use kernel::EventController;
use Getopt::Long;
use kernel::cgi;
use DBI;
use POSIX;
use vars qw($opt_v $opt_h $opt_c $opt_t $opt_s $opt_q $opt_l $configname);
exit(1) if (!GetOptions('verbose'=>\$opt_v,
                        'smallpack=i'=>\$opt_s,
                        'tasks=i'=>\$opt_t,
                        'quietmode'=>\$opt_q,
                        'limittime=i'=>\$opt_l,
                        'debug'=>\$opt_v,
                        'help'=>\$opt_h,
                        'config=s'=>\$opt_c));
my @ObjectFilter=@ARGV;

if ($opt_q){
   open STDOUT, '>>/dev/null' or die "Can't write to /dev/null: $!";
}

my $ReplicationStart=time();
if ($opt_h){
   Help();exit(255);
}
if ($opt_v){
   $W5V2::Debug=1;
}
else{
   $W5V2::Debug=0;
}



if ($ENV{REMOTE_USER} eq ""){
   if ($ENV{USER} ne ""){
      $ENV{REMOTE_USER}="system/$ENV{USER}";
   }
   else{
      $ENV{REMOTE_USER}="system/unknown";
   }
   $ENV{REAL_REMOTE_USER}="system/W5Replicate";
}
$W5V2::OperationContext="W5Replicate";



#
# handling option to set commandline specfied config-name
#
if ($opt_c eq ""){
   $opt_c="w5replicate";
}
$configname=$opt_c;

#
# small pack of records, witch be passed in one operation (commit)
#
my $smallpack=100;
if ($opt_s ne ""){
   if ($opt_s=~m/^\d+$/){
      $smallpack=$opt_s;
   }
   else{
      Help();exit(255);
   }
}

#
# handling limitation of parallel tasks
#
my $maxslots=3;
if ($opt_t ne ""){
   if ($opt_t=~m/^\d+$/){
      $maxslots=$opt_t;
   }
   else{
      Help();exit(255);
   }
}
msg(DEBUG,"use maximum slots=$maxslots");

#
# handling limitation replication time (time window to replicate)
#
my $MaximumReplicationTime=60;
if ($opt_l ne ""){
   if ($opt_l=~m/^\d+$/){
      $MaximumReplicationTime=$opt_l;
   }
   else{
      Help();exit(255);
   }
}
if ($MaximumReplicationTime<20){
   $MaximumReplicationTime=20;
}
msg(DEBUG,"use MaximumReplicationTime=$MaximumReplicationTime seconds");




my %ClientParam=();

my $config=new kernel::config();

if (!$config->readconfig("$FindBin::Bin/..",$configname)){
   msg(ERROR,"can't read configfile '%s'",$configname);
   exit(1);
}
{
   my $port=$config->Param("W5SERVERPORT");
   $port=4711 if ($port eq "");
   msg(DEBUG,"W5ServerPort=%s",$port);
   $ClientParam{'PeerPort'}=$port;
}

my $MyClient=new RPC::Smart::Client(%ClientParam);
my $self=new kernel::App(Config=>$config);
if (!defined($W5V2::Translation{$self})){
   $W5V2::Translation{$self}={self=>$self,tab=>{}};
}
$W5V2::Translation=$W5V2::Translation{$self};

if (! defined($MyClient->Connect())){
   msg(ERROR,"can't connect to server");
   exit(1);
}
if (!defined($W5V2::W5Server)){
   my %ClientParam;
   $ClientParam{'PeerAddr'}=$self->Config->Param("W5SERVERHOST");
   $ClientParam{'PeerPort'}=$self->Config->Param("W5SERVERPORT");
   $W5V2::W5Server=new RPC::Smart::Client(%ClientParam);
   $W5V2::W5Server->Connect();
}
$W5V2::Query=new kernel::cgi({});
my $EventController=new kernel::EventController(Config=>$config);
$EventController->Cache->{W5Server}=$W5V2::W5Server;


#
#                      Init finished
#==================================================================
#

#
# filtering requested objects
#
sub filterMatch
{
  #({obj=>$ctrl->{'name'}},\@ObjectFilter)
  my $arg=shift;
  my $flt=shift;
  my $match=0;

  if (exists($arg->{id})){   # is record-filter request

  }
  else{                      # is object filtering
     foreach my $frec (@$flt){
        my $neg=0;
        my $o=$frec->{obj};
        if ($o=~m/^\!/){
           $o=~s/^\!//;
           $neg=1;
        }
        my $qo=quotemeta($o);
        $qo=~s/\\\*/.*/g;
        if ($arg->{'obj'}=~m/^$qo$/){
           if (!$neg){
              $match=1;
           }
           else{
              return(0);
           }
        }
        else{
           if ($neg){
              $match=1;
           }
           else{
              return(0);
           }
        }
     }
  }
  return($match);
}



#
# Connect to replication target oracle DB via DBI
#
sub getOracleDBIConnectionHandle
{
   my $dbconnect=$config->Param("ORACONNECT");
   my $dbuser=$config->Param("ORAUSER");
   my $dbpass=$config->Param("ORAPASS");
   msg(INFO,"try ora connect='$dbconnect' user='$dbuser'");

   if ($dbconnect eq "" || $dbuser eq "" || $dbpass eq ""){
      msg(ERROR,"fatal error - not enough connection informations");
      exit(255);
   }
   my $dst=DBI->connect($dbconnect,$dbuser,$dbpass,{
          AutoCommit=>0,
          FetchHashKeyName=>'NAME_lc',});
   $dst->{'LongTruncOk'} = 1;
   $dst->{'LongReadLen'} = 128000;
   if (!defined($dst)){
      msg(ERROR,$DBI::errstr);
      exit(100);
   }
   $dst->doCmd("alter session set NLS_DATE_FORMAT='YYYY-MM-DD HH24:MI:SS'");
   msg(INFO,"connect to replication target '$dbconnect' successfull");
   return($dst,uc($dbuser),lc($dbuser).'@'.lc($dbconnect));
}


sub getReplicateObjectRec
{
   my $Config=shift;
   my $rprec=shift;
   my $objectname=shift;

   my $ro=getModuleObject($Config,"replicate::obj");
   if (!defined($ro)){
      die("ERROR: can not access replicate::obj");
   }
   $ro->SetFilter({name=>\$objectname,partnerid=>\$rprec->{id}});
   my ($rorec,$msg)=$ro->getOnlyFirst(qw(ALL));
   if (!defined($rorec)){
      my $newid=$ro->ValidatedInsertRecord({name=>$objectname,
                                            partnerid=>$rprec->{id}});
      if (!defined($newid)){
         msg(ERROR,"can not initialize replication object record");
         exit(101);
      }
      else{
         $ro->SetFilter({id=>\$newid});
         ($rorec,$msg)=$ro->getOnlyFirst(qw(ALL));
      }
   }
   if (!defined($rorec)){
      die("ERROR: can not load object record");
   }
   return($rorec);
}


sub getReplicatePartnerRec
{
   my $Config=shift;
   my $partner=shift;

   my $rp=getModuleObject($Config,"replicate::partner");
   if (!defined($rp)){
      die("ERROR: can not access replicate::partner");
   }
   $rp->SetFilter({name=>\$partner});
   my ($rprec,$msg)=$rp->getOnlyFirst(qw(ALL));
   if (!defined($rprec)){
      my $newid=$rp->ValidatedInsertRecord({name=>$partner,cistatusid=>'4'});
      if (!defined($newid)){
         msg(ERROR,"can not initialize replication partner record");
         exit(101);
      }
      else{
         $rp->SetFilter({id=>\$newid});
         ($rprec,$msg)=$rp->getOnlyFirst(qw(ALL));
      }
   }
   if (!defined($rprec)){
      die("ERROR: can not load partner record");
   }
   return($rprec);
}


#
# scans replication target by requested objects and attributes
#
sub getRequestedReplicationObjects
{
   my $Config=shift;
   my @replicationOjects;
   my ($dbi,$schema,$partner)=getOracleDBIConnectionHandle();

   my $rprec=getReplicatePartnerRec($Config,$partner);




   #
   # loading table list from oracle schema and check tables with :: in it
   # tables with a two douplepoints will be used as sync objects
   #
   my $sth=$dbi->table_info(undef,$schema,'%');
   foreach my $tab ($sth->getHashList()){
      if ($tab->{'table_name'}=~m/::/){ # objects are recognizable by :: 
         my %ctrl=('name'=>$tab->{'table_name'},
                   'prio'=>'0',
                   'valid'=>'0',
                   'requested'=>'1');
         push(@replicationOjects,\%ctrl);
      }
   }

   #
   # the fields in the tables with :: are automaticly the view to 
   # w5base. If the fieldname begins with w5, it will be ignored in view.
   #
   foreach my $ctrl (@replicationOjects){
      my $replkey_found=0;
      $ctrl->{'view'}=[];
      $ctrl->{'columns'}=[];
      $ctrl->{'col'}={};
      my $sth=$dbi->column_info(undef,$schema,$ctrl->{'name'},'%');
      foreach my $col ($sth->getHashList()){
         $ctrl->{'col'}->{lc($col->{'column_name'})}={
                               'name'=>$col->{'column_name'},
                               'type'=>$col->{'type_name'},
                               'size'=>$col->{'column_size'}
         };
         push(@{$ctrl->{'columns'}},
              $ctrl->{'col'}->{lc($col->{'column_name'})});
         if (!(lc($col->{'column_name'})=~m/^w5/)){
            push(@{$ctrl->{'view'}},lc($col->{'column_name'}));
         }
         if (lc($col->{'column_name'}) eq "w5replkey"){
            $replkey_found++;
         }
      }

      #
      # validating object names against the connected w5base system
      #
      if ($replkey_found){
         my $obj=getModuleObject($Config,$ctrl->{'name'});
         if (defined($obj)){
            my $idobj=$obj->IdField();
            if (defined($idobj)){
               my $idname=$idobj->Name();
               $ctrl->{'idname'}=$idname;
               if (exists($ctrl->{'col'}->{lc($idname)})){ # check on id col
                  $ctrl->{'valid'}=1;
                  $ctrl->{'replkeyfields'}=['replkeypri','replkeysec'];
               }
            }
            my $syncobj=$obj->getField("replkeypri");
            if (!defined($syncobj)){
               msg(ERROR,"remote object '$ctrl->{'name'}' ".
                         "is not replication compatible");
               $ctrl->{'valid'}=0;
            }
         }
      }
      else{
         msg(ERROR,"missing essential target fields in ora ".
                   "object '$ctrl->{'name'}'");
         $ctrl->{'valid'}=0;
      }
   }
   $dbi->commit();
   $dbi->disconnect();

   if ($#ObjectFilter!=-1){
      my @objflt;
      foreach my $k (@ObjectFilter){
         if (my ($obj,$id)=$k
             =~m/^(!{0,1}[a-z0-9*_]+::[a-z0-9*_]+)(\[.*\]){0,1}$/i){
            my %f=(obj=>$obj);
            if (defined($id)){
               $f{'id'}=$id;
            }
            push(@objflt,\%f);
         }
         else{
            msg(ERROR,"invalid object/element filter '$k'");
            exit(255);
         }
      }

      @ObjectFilter=@objflt;
      foreach my $ctrl (@replicationOjects){ 
         $ctrl->{'requested'}=0;
         if (filterMatch({obj=>$ctrl->{'name'}},\@ObjectFilter)){
            $ctrl->{'requested'}=1;
            msg(INFO,"object '$ctrl->{name}' requested by filter");
         }
         else{
            msg(INFO,"object '$ctrl->{name}' NOT requested");
         }
      }
   }



   return(@replicationOjects);
}

#
# Phase1 replication process for a specified object - in this phase, the
# new inserted or modified records are collected
#
sub objectReplicationPhase1
{
   my $Config=shift;
   my $phaselimit=shift;
   my $ctrl=shift;
   my $start=time();



   msg(INFO,"============================================");
   msg(INFO,"start: phase 1 replication for $ctrl->{name} - new records");
   my ($dbi,$schema,$partner)=getOracleDBIConnectionHandle();



   my $obj=getModuleObject($Config,$ctrl->{'name'});
   if (!defined($obj)){
      msg(ERROR,"can not connect to $ctrl->{name}");
      return(undef);
   }

   my $rprec=getReplicatePartnerRec($Config,$partner);
   my $rorec=getReplicateObjectRec($Config,$rprec,$ctrl->{'name'});

   my $rstatobj=getModuleObject($Config,"replicate::stat");
   my $rstatid=$rstatobj->ValidatedInsertRecord({
                                                   phase=>1,
                                                   objectid=>$rorec->{id},
                                                   startdate=>NowStamp("en")
                                                });
   if (!defined($rstatid)){
      $dbi->rollback();
      $dbi->disconnect();
      die("can not create State-Record for phase 1 on $ctrl->{'name'}");
   }
   my $oldreplkey;
   while($ReplicationStart+$MaximumReplicationTime-10>time() &&
         $start+$phaselimit>time()){
      my $syncstart;
      my $replkeysec;
      my $cmd="select max(w5replkey) sstart from \"$ctrl->{name}\"";
      foreach my $rec ($dbi->getHashList($cmd)){
         $syncstart=$rec->{'sstart'};
      }
      $obj->ResetFilter();
      $obj->Limit($smallpack,0,0);
      if (defined($syncstart)){ # restart sync process at 
                                # last known position
         my $cmd="select w5replkeypri p,w5replkeysec s ".
                 "from \"$ctrl->{name}\" ".
                 "where w5replkey=?";
         my $replkey;
         foreach my $rec ($dbi->getHashList($cmd,$syncstart)){
            $replkey=trim($rec->{'p'});
            $replkeysec=trim($rec->{'s'});
         }
         if (defined($replkey)){
            if ($replkey ne $oldreplkey){  # do small steps
               $obj->SetFilter({'replkeypri'=>">=\"".$replkey."\""});
               $obj->Limit($smallpack,0,0);
            }
            else{
               $obj->SetFilter({'replkeypri'=>\$replkey});
               my $n=$obj->CountRecords();
               $obj->ResetFilter();
               $obj->SetFilter({'replkeypri'=>">=\"".$replkey."\""});
               if ($n>$smallpack-1){
                  msg(WARN,"found $n records with the same replkey '%s'",
                      $replkey);
                  $obj->Limit($n+$smallpack,0,0);
               }
               else{
                  $obj->Limit($smallpack,0,0);
               }
            }
         }
      }
#msg(WARN,"pack %d",time());
      my @syncfields=@{$ctrl->{'replkeyfields'}};
      $obj->SetCurrentView(@syncfields,@{$ctrl->{'view'}});
      $obj->SetCurrentOrder(@syncfields);

      my ($srcrec,$msg)=$obj->getFirst(buffer=>0);
      my $processed=0;
      if (defined($srcrec)){
         do{
            $oldreplkey=$srcrec->{'replkeypri'};
            if (defined($replkeysec) && $srcrec->{'replkeysec'} ge $replkeysec){
               $replkeysec=undef;
            }
            if (!defined($replkeysec)){   # seek to synkey1 position in stream
               if (!$dbi->InsertOrUpdate($ctrl,$srcrec)){
                  msg(ERROR,"REPLICATION BREAK: fail to write in ".
                            "object '$ctrl->{'name'}'");
                  $dbi->commit();
                  $dbi->disconnect();
                  return;
               }
               $processed++;
               $dbi->commit();
            }
            ($srcrec,$msg)=$obj->getNext();
         } until(!defined($srcrec));
      }
      if ($processed<2){
         last;
      }
   }


   $dbi->commit();
   $dbi->disconnect();
   msg(INFO,"end:   phase 1 replication for $ctrl->{name}");
   my $rstatid=$rstatobj->ValidatedUpdateRecord({},
                                                {
                                                   enddate=>NowStamp("en")
                                                },
                                                {id=>\$rstatid});
}



#
# Phase2 replication process for a specified object - in this phase, the
# refresh and aging will be controlled
#
sub objectReplicationPhase2
{
   my $Config=shift;
   my $phaselimit=shift;
   my $ctrl=shift;
   my $start=time();
   msg(INFO,"============================================");
   msg(INFO,"start: phase 2 replication for $ctrl->{name} - refresh");
   my ($dbi,$schema,$partner)=getOracleDBIConnectionHandle();
   my $obj=getModuleObject($Config,$ctrl->{'name'});
   if (!defined($obj)){
      msg(ERROR,"can not connect to $ctrl->{name}");
      return(undef);
   }

   my $rprec=getReplicatePartnerRec($Config,$partner);
   my $rorec=getReplicateObjectRec($Config,$rprec,$ctrl->{'name'});

   my $rstatobj=getModuleObject($Config,"replicate::stat");
   my $rstatid=$rstatobj->ValidatedInsertRecord({
                                                   phase=>2,
                                                   objectid=>$rorec->{id},
                                                   startdate=>NowStamp("en")
                                                });

   if (!defined($rstatid)){
      $dbi->rollback();
      $dbi->disconnect();
      die("can not create State-Record for phase 2 on $ctrl->{'name'}");
   }

   my $cmd="select count(*) n ".
           "from \"$ctrl->{name}\" ";
   my $n=0;
   my $basewhere="";
   my $rec=$dbi->getHash($cmd);

   if (my $rec=$dbi->getHash($cmd)){
      $n=$rec->{'n'};
      if ($n>100){
         $n=int($n/14);
         my $cmd="select (m1.max-m2.min)/4+m2.min avg ".
                 "from ".
                 "(select max(w5repllasttry) max from \"$ctrl->{name}\") m1,".
                 "(select min(w5repllasttry) min from \"$ctrl->{name}\") m2";
         if (my $drec=$dbi->getHash($cmd)){
            $basewhere="where w5repllasttry<'$drec->{avg}' ".
                       "and w5repllasttry<SYSDATE-(1/24) and ROWNUM<$n ";
         }
      }
   }
   my %idseen=();
   SPLOOP: while($ReplicationStart+$MaximumReplicationTime-10>time() &&
         $start+$phaselimit>time()){
      my $curSyncTime=time()-$ReplicationStart;

      my $cmd="select * from ".
              "(select $ctrl->{idname} from \"$ctrl->{name}\" ".$basewhere.
              "order by w5repllasttry) ".
              "where rownum<$smallpack";
      msg(INFO,"oracmd=$cmd");
      my @buffer=$dbi->getHashList($cmd);
      if ($#buffer==-1){
         last;
      }
      foreach my $rec (@buffer){
         my $id=$rec->{$ctrl->{idname}};
         last SPLOOP if (exists($idseen{$id}));  # end if an ID is already seen
         $idseen{$id}++;
         $dbi->doCmd("update \"$ctrl->{name}\" set w5repllasttry=sysdate ".
                     "where $ctrl->{idname}=?",$id);
         $obj->ResetFilter();
         $obj->SetFilter({$ctrl->{idname}=>\$id});
         my ($rrec,$msg)=$obj->getOnlyFirst(@{$ctrl->{'replkeyfields'}},
                                            @{$ctrl->{'view'}});
         if (defined($rrec)){
            if (!$dbi->InsertOrUpdate($ctrl,$rrec)){
               msg(ERROR,"REPLICATION BREAK: fail to refresh in ".
                         "object '$ctrl->{'name'}'");
               $dbi->commit();
               $dbi->disconnect();
               return;
            }
         }
         else{
            $dbi->doCmd("update \"$ctrl->{name}\" ".
                        "set w5replfailcnt=w5replfailcnt+1 ".
                        "where $ctrl->{idname}=?",$id);
         }
      }
      $dbi->commit();
   }
   $dbi->commit();
   $dbi->disconnect();
   msg(INFO,"end:   phase 2 replication for $ctrl->{name}");
   my $rstatid=$rstatobj->ValidatedUpdateRecord({},
                                                {
                                                 enddate=>NowStamp("en"),
                                                 effentries=>int(keys(%idseen))
                                                },
                                                {id=>\$rstatid});
}


#
# Phase3 replication process for a specified object - in this phase, the
# old/aged elements will be deleted
# Per default, all records with a failcount>2 and last success older then
# 7 days, will be deleted
#
sub objectReplicationPhase3
{
   my $Config=shift;
   my $phaselimit=shift;
   my $ctrl=shift;
   my $start=time();
   msg(INFO,"============================================");
   msg(INFO,"start: phase 3 replication for $ctrl->{name} - refresh");
   my ($dbi,$schema,$partner)=getOracleDBIConnectionHandle();

   my $rprec=getReplicatePartnerRec($Config,$partner);
   my $rorec=getReplicateObjectRec($Config,$rprec,$ctrl->{'name'});

   my $rstatobj=getModuleObject($Config,"replicate::stat");
   my $rstatid=$rstatobj->ValidatedInsertRecord({
                                                   phase=>3,
                                                   objectid=>$rorec->{id},
                                                   startdate=>NowStamp("en")
                                                });


 #  if (!defined($rstatid)){
 #     $dbi->rollback();
 #     $dbi->disconnect();
 #     die("can not create State-Record for phase 3 on $ctrl->{'name'}");
 #  }

   my $cmd="delete from \"$ctrl->{name}\" ".
           "where w5repllastsucc<sysdate-7 and w5replfailcnt>2";
   msg(INFO,"oracmd=$cmd");
   $dbi->doCmd($cmd);
   $dbi->commit();
   $dbi->disconnect();
   msg(INFO,"end:   phase 3 replication for $ctrl->{name}");
   my $rstatid=$rstatobj->ValidatedUpdateRecord({},
                                                {
                                                   enddate=>NowStamp("en")
                                                },
                                                {id=>\$rstatid});
}


sub createSlot
{
   my $self=shift;
   my $tasklabel=shift;
   my $nice=shift;
   my $ctrl=shift;
   my $function=shift;

   my $pid=fork();
   if ($pid==0){
      POSIX::nice($nice);
      {   # reset eviroment
         $W5V2::W5Server=undef;
         my %ClientParam;
         $ClientParam{'PeerAddr'}=$self->Config->Param("W5SERVERHOST");
         $ClientParam{'PeerPort'}=$self->Config->Param("W5SERVERPORT");
         $W5V2::W5Server=new RPC::Smart::Client(%ClientParam);
         $W5V2::W5Server->Connect();
         $self->Cache->{W5Server}=$W5V2::W5Server;
      }
      exit(&$function());
   }

   return({pid=>$pid,
           label=>$tasklabel,
           name=>$ctrl->{'name'},
           start=>time()});
}



#                                    
#==================================================================
#                       MAIN         

my @ReplicationObjects=getRequestedReplicationObjects($config);

my @joblist;

foreach my $replControl (@ReplicationObjects){
   if ($replControl->{'valid'} && $replControl->{'requested'}){
      unshift(@joblist,{phase=>1,replControl=>$replControl});
      push(@joblist,{phase=>2,replControl=>$replControl});
      push(@joblist,{phase=>3,replControl=>$replControl});
   }
}

my @slot;
my $phaselimit=int($MaximumReplicationTime/2*3)-15;
my $currentStartPhase;
while(my $nextjob=shift(@joblist)){
   for(my $slotno=0;$slotno<$maxslots;$slotno++){
      if (!defined($slot[$slotno])){
         my $replControl=$nextjob->{'replControl'};
         if ($replControl->{'valid'} && $replControl->{'requested'}){
            if ($nextjob->{'phase'}==1){
               $currentStartPhase=1;
               $slot[$slotno]=createSlot($self,"Phase1",1,$replControl,sub{
                  objectReplicationPhase1($config,$phaselimit,$replControl);
               });
            }
            elsif ($nextjob->{'phase'}==2){ 
               if ($currentStartPhase<2){ # change phase limit on sw lev2
                  $phaselimit=$MaximumReplicationTime-
                              (time()-$ReplicationStart);
                  if ($#joblist!=-1){
                     $phaselimit=int($phaselimit/($#joblist+1))-5;
                     $phaselimit=10 if ($phaselimit<10);
                  }
               }
               $currentStartPhase=2;
               $slot[$slotno]=createSlot($self,"Phase2",10,$replControl,sub{
                  objectReplicationPhase2($config,$phaselimit,$replControl);
               });
            }
            elsif ($nextjob->{'phase'}==3){  # cleanup
               $currentStartPhase=3;
               $slot[$slotno]=createSlot($self,"Phase3",2,$replControl,sub{
                  objectReplicationPhase3($config,10,$replControl);
               });
            }
         }
         last;
      }
   }
   while(1){
      my $freeslotcount=0;
      my $runnging=0;
      for(my $slotno=0;$slotno<$maxslots;$slotno++){
         if (defined($slot[$slotno])){
            my $s=$slot[$slotno];
            $runnging++;
            if (kill(0,$s->{pid})){
               if ((my $sysexitcode=waitpid($s->{pid},WNOHANG))>0){
                  my $sig=$sysexitcode&8;
                  $s->{'exitstate'}=$sig;
                  $s->{'end'}=time();
               }
            }
            else{
               delete($slot[$slotno]);
            } 
         }
         else{
            $freeslotcount++;
         }
      }
      if (($freeslotcount>0 && $#joblist!=-1) || 
          ($#joblist==-1 && $runnging==0)){
         last;
      }
      sleep(1);
      msg(INFO,"freeslotcount=$freeslotcount joblist=$#joblist ".
               "run=$runnging max=$maxslots");
   }
   msg(INFO,"next job request from joblist=$#joblist");
}
msg(INFO,"OK, done");
exit(0);

#==================================================================
sub Help
{
   printf("Usage: W5Replicate [OPTIONS] [OBJECTS]\n");
   printf("\n");
   my $form=" %-60s %17s\n";
   printf("OPTIONS:\n");
   printf($form,"--config     configuration file",
          "[replicate.conf]");
   printf($form,"--debug      enable debug messages",
          "[false]");
   printf($form,"--quietmode  disable all INFO messages to STDOUT",
          "[false]");
   printf($form,"--limittime  limit t for replication process in sec",
          "[60]");
   printf($form,"--phase      process the specified phases",
          "[1,2,3]");
   printf($form,"--tasks      limit the count of parallel processes",
          "[3]");
   printf("\n");
   printf("OBJECTS:\n");
   printf("None, one or more object names (in W5Base interal notation), ".
          "witch\nare should be replicated. If the Notation object(id) is ".
          "used,\nonly the specified record id will be replicated.\n".
          "f.e.:\n".
          "base::user base::grp itil::system !base::workflow ...\n".
          "base::location(12711643270034)\n\n");
}
#==================================================================


package DBI::st;

sub getHashList
{
   my $self=shift;
   my @bind=@_;
   my @l;

   if ($self->execute(@bind)){
      while(my $dbrec=$self->fetchrow_hashref()){
         push(@l,$dbrec);
      }
      return(@l);
   }
   return(undef);
}

sub getHash
{
   my $self=shift;
   my @bind=@_;
   my @l;

   if ($self->execute(@bind)){
      my $dbrec=$self->fetchrow_hashref();
      return($dbrec);
   }
   return(undef);
}

package DBI::db;
use W5Kernel;
use Data::Dumper;

sub getHashList
{
   my $self=shift;
   my $cmd=shift;
   if (my $sth=$self->prepare($cmd)){
      return($sth->getHashList(@_));
   }
   return(undef);
}

sub getHash
{
   my $self=shift;
   my $cmd=shift;
   if (my $sth=$self->prepare($cmd)){
      my $dbrec=$sth->getHash(@_);
      $sth->finish();
      $self->commit();
      return($dbrec);
   }
   else{
      die("while prepare $cmd"); 
   }
   return(undef);
}

sub preprocessRecord
{
   my $self=shift;
   my ($ctrl,$reqrec,$col)=@_;
   my %rec=(%$reqrec);

   $rec{'w5replkey'}=sprintf("%35s%35s",$rec{'replkeypri'},$rec{'replkeysec'});
   $rec{'w5replkey'}=~s/ /0/g;
   $rec{'w5replkeypri'}=$rec{'replkeypri'};
   $rec{'w5replkeysec'}=$rec{'replkeysec'};
   foreach my $k (@{$ctrl->{'replkeyfields'}}){
      delete($rec{$k});
   }
   foreach my $fieldname (keys(%rec)){
      if ($col->{$fieldname}->{'type'} =~ m/^[char|varchar]/i) {
         if (length($rec{$fieldname})>$col->{$fieldname}->{'size'}){
            $rec{$fieldname}=substr($rec{$fieldname},0,
                                    $col->{$fieldname}->{'size'});
         }
      }
      if (scalar($rec{$fieldname}) =~ m/^Container=HASH/) {
         $rec{$fieldname}=$self->Hash2DataField($rec{$fieldname});
      }
      if (ref($rec{$fieldname}) eq "ARRAY"){
         $rec{$fieldname}=join("; ",@{$rec{$fieldname}});
      }
   }
   return(\%rec);
}


sub isChanged
{
   my $self=shift;
   my $ctrl=shift;
   my $oldrec=shift;
   my $newrec=shift;

   my $changecount=0;
   foreach my $k (keys(%$newrec)){
      if (!($k=~m/^w5repl.*$/i)){
         if (trim($newrec->{$k}) ne trim($oldrec->{$k})){
            $changecount++;
            msg(INFO,sprintf("%s: old='%s' new='%s'",$k,$oldrec->{$k},
                                                        $newrec->{$k}));
         }
      }
   }
   return($changecount);
}




sub InsertOrUpdate
{
   my $self=shift;
   my $ctrl=shift;
   my $reqrec=shift;
   my $dbtable=$ctrl->{'name'};
   my $idname=$ctrl->{'idname'};
   my $col=$ctrl->{'col'};

   my $rec=$self->preprocessRecord($ctrl,$reqrec,$col);

   my $cmd="select * from \"$dbtable\" where $idname=?";
   my $idval=$rec->{$idname};
   my @curlist=$self->getHashList($cmd,$idval);
   my @view=keys(%$rec);
   if ($#curlist==0){     # do an update
      my $isChanged=$self->isChanged($ctrl,$curlist[0],$rec);
      my (@v,@values);
      foreach my $fieldname (@view){
         push(@values,$rec->{$fieldname});
         if ($col->{$fieldname}->{type} =~ m/^[timestamp|date]/i) {
            push(@v,"$fieldname=to_date(?,'YYYY-MM-DD HH24:MI:SS')");
         }
         else {
            push(@v,"$fieldname=?");
         }
      }
      push(@v,"w5repllastsucc=sysdate");
      push(@v,"w5replfailcnt=0");
      if ($isChanged){
         push(@v,"w5replmdate=sysdate");
      }
      my $v=join(",",@v);
      my $updcmd="update \"$dbtable\" set $v where $idname=?";
      msg(INFO,"upd: $updcmd");
      return($self->doCmd($updcmd,@values,$idval));
   }
   elsif ($#curlist==-1){ # do an insert
      my @values;
      my @place;
      foreach my $fieldname (@view) {
         push(@values,$rec->{$fieldname});
         if ($col->{$fieldname}->{type} =~ m/^[timestamp|date]/i) {
            push(@place,"to_date(?,'YYYY-MM-DD HH24:MI:SS')");
         }
         else {
            push(@place,"?");
         }
      }
      #my @values=map({$rec->{$_}} @view);
      #my @place=map({'?'} @view);
      if (exists($ctrl->{'col'}->{'w5replmdate'})){
         push(@view,'w5replmdate');
         push(@place,'sysdate');
      }
      if (exists($ctrl->{'col'}->{'w5replcdate'})){
         push(@view,'w5replcdate');
         push(@place,'sysdate');
      }
      
      my $inscmd="insert into \"$dbtable\" ".
        "(".join(",",@view,"w5repllastsucc","w5repllasttry").") ".
        "values(".join(",",@place,'sysdate','sysdate').")";
      msg(INFO,"ins: $inscmd");
      return($self->doCmd($inscmd,@values));
   }
   else{
      msg(ERROR,"ganz scheisse!");
      exit(-12356);
   }
   return(undef);
}



sub Hash2DataField
{
   my $self=shift;
   my $container=shift;
   my $element;
   if (exists($container->{'item'}) && 
       scalar($container->{'item'}) =~ m/^ARRAY/) {
      foreach my $item (@{$container->{'item'}}) {
         $element.=$item->{'name'}.
                   "='".$item->{'value'}."'=".
                   $item->{'name'}."\n";
      }
   }
   return($element);
}

sub effectedRows
{
   my $self=shift;
   return($self->{effectedRows});
}

sub doCmd
{
   my $self=shift;
   my $cmd=shift;
   $self->{effectedRows}=undef;
   if (my $sth=$self->prepare($cmd)){
      my $bk=$sth->execute(@_);
      $self->{effectedRows}=$sth->rows();
      return($bk);
   }
   return(undef);
}




