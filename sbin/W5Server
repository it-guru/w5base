#!/usr/bin/env perl
package W5Server;
use FindBin;
use lib "$FindBin::Bin/../lib";
use lib "$FindBin::Bin/../mod";
use strict;
use vars qw(@ISA);
use RPC::Smart::Server;
use RPC::Smart::Client;
use Data::Dumper;
use Date::Calc qw(Today_and_Now);
use kernel;
use kernel::App;
use kernel::cgi;
use kernel::EventController;
use IO::Select;
use File::Temp qw(tempfile);
use POSIX;
use Fcntl;
use Scalar::Util;

@ISA=qw(RPC::Smart::Server kernel::App);

*CORE::GLOBAL::die = sub {
   if (Scalar::Util::blessed($_[0])){
      CORE::die(@_);
   }
   require Carp; Carp::confess
};

#
# This is the primary call to the W5Server. With this method all
# event procedures can be initiated.
#
sub rpcCallEvent
{
   my $self=shift;
   return($self->rpcCallSerialEvent(@_));
}


sub rpcCallSerialEvent
{
   my $self=shift;
   my $event=shift;
   my @p=@_;

   if ($self->Config->Param("W5BaseOperationMode") eq "readonly"){
      return({exitcode=>0,msg=>'readonly mode'});
   }
   if ($self->{ServerGoesDown}){
      return({exitcode=>1,msg=>'server goes down'});
   }
   my $eventlabel=$event." ".join(" ",map({"'".$_."'"} @p));
   if ($self->{EventController}->isEvent($event)){
      my $timeout=$self->{EventController}->getMaxEventTimeout($event);
      return($self->async(sub {
         my $tasks=$self->getTasksHash();  # this should be done in RPC::Server,
         %{$tasks}=();                     # but at this position, i didnt need
         $0="W5Server '$event'";
         $self->initAsyncEnv($event,{param=>[@p]},'any');
         $SIG{USR1}='DEFAULT';
         $SIG{USR2}='DEFAULT';
         $SIG{CHLD}='DEFAULT';
         $SIG{ALRM}='DEFAULT';
         $self->{EventController}->setParent($self);
         my @methods=$self->{EventController}->getEventMethods($event);
         msg(DEBUG,"rpcCallSerialEvent: name=$event timeout=$timeout ".
                   "methods=%d",$#methods+1);
         my @bk;
         my $joblog=getModuleObject($self->Config,"base::joblog");
         msg(DEBUG,"joblog=$joblog");
         my $exitcode=0;
         foreach my $method (@methods){
            my %jobrec=(name=>$method,event=>$eventlabel,pid=>$$);
            my $jobid=$joblog->ValidatedInsertRecord(\%jobrec);
            msg(DEBUG,"jobid=$jobid");
            my @subbk=$self->{EventController}->ProcessEvent($event,
                                                             {param=>[@p]},
                                                             $method);
            for(my $c=0;$c<=$#subbk;$c++){
               if (ref($subbk[$c]) eq "HASH"){
                  $subbk[$c]->{jobid}=$jobid;
                  if (!exists($subbk[$c]->{exitcode}) ||
                      $subbk[$c]->{exitcode}!=0){
                     $exitcode=$subbk[$c]->{exitcode};
                  }
               }
               else{
                  $exitcode="1000";
               }
            }
            push(@bk,@subbk);
         }
         $exitcode=1 if ($#bk==-1);
         return({exitcode=>$exitcode,handlerresult=>\@bk});
      },timeout=>$timeout,name=>$event));
   }
   return({exitcode=>1,nohandler=>1});
}


#
# The call rpcGetSSHkey is designed to get access to the W5Server
# SSH2 Public key from Web-Frontend. This is needed, to show this
# information for users, which will allow the W5Server to access
# to here servers.
#
sub rpcGetSSHkey
{
   my $self=shift;
   if (! -d $ENV{HOME}){
      return({exitcode=>1,msg=>"can't access home $ENV{HOME}"});
   }
   if (! -d $ENV{HOME}."/.ssh"){
      return({exitcode=>1,msg=>"can't access home $ENV{HOME}/.ssh"});
   }
   if (! -r $ENV{HOME}."/.ssh/id_dsa.pub"){
   }
   if (!open(F,"<".$ENV{HOME}."/.ssh/id_dsa.pub")){
      return({exitcode=>1,msg=>"can't access home $ENV{HOME}/.ssh/id_dsa.pub"});
   }
   my $key=join("",<F>);
   $key=~s/\s*$//;
   close(F);

   return({exitcode=>0,key=>$key});
}


#
# The call rpcReloadW5Server allows a reload of the W5Server to
# ensure a new load of all modules. This function is not perfectly
# tested!
#
sub rpcReloadW5Server
{
   my $self=shift;
   my $name=shift;

   msg(DEBUG,"reload request for '$name' - active Servers:\n==>%s",
             join("\n==>",keys(%{$self->{W5ServerProcess}})));
   if (exists($self->{W5ServerProcess}->{$name})){
      my $pid=$self->{W5ServerProcess}->{$name}->{AsyncID};
      if (kill(1,$pid)){
         return({exitcode=>0});
      }
      return({exitcode=>2,msg=>"fail to send reconfigure signal"});
   }
   return({exitcode=>1,msg=>"unknown or inactive server $name"});
}


sub rpcProcessState
{
   my $self=shift;
   return($self->rpcAsyncState(@_));
}

sub rpcAsyncState
{
   my $self=shift;
   my $id=shift;
   my $tasks=$self->getTasksHash();

   if (!defined($id) || !defined($tasks->{$id})){
      return({exitcode=>1,invalidAsyncID=>1});
   }
   my %res=%{$tasks->{$id}};
   my $ipcval=$tasks->{$id}->{ipc}->fetch();
   delete($res{ipc}); 
   my $VAR1=undef;
   eval($ipcval);
   if ($@ eq ""){
      $res{ipc}=$VAR1;
   }
   return({exitcode=>0,process=>\%res});
}

#
# a sample of the notification of the users on change of faq entry
#
# $w5server->Call("rpcCallSpooledEvent",            # sample
#                 "faqnotify-123456789012345",      # unique tag
#                 600,3600,12                       # timing
#                 423423423423,                     # id of calling user or 0
#                 "notifyFaqListener","123456789012345") # event call
#

sub rpcCallSpooledEvent
{
   my $self=shift;
   my %param=@_;
   #msg(DEBUG,"rpcCallSpooledEvent\n%s",Dumper(\@_));
   my $spooltag=$param{spooltag};  # tag label of the event (is unique)
   my $firstcalldelay=$param{firstcalldelay}; 
                                   # try to call the event in n seconds at first
   my $interval=$param{interval};  # retry if the first call fails
   my $retrycount=$param{retrycount};      # maximum retry count
   my $userid=$param{userid};      # user witch calls the event
   my $name=$param{eventname};     # eventname
   my $redefine=$param{redefine};  # eventname
   my @p;
   if (defined($param{eventparam}) && ref($param{eventparam}) eq "ARRAY"){
      @p=@{$param{eventparam}};
   }
   else{
      @p=($param{eventparam});
   }
   if ($userid==0){
      return({exitcode=>1,msg=>'ERROR: no userid given'});
   }
   if ($self->Config->Param("W5BaseOperationMode") eq "readonly"){
      return({exitcode=>0,msg=>'readonly mode'});
   }
   $redefine=0          if (!defined($redefine));
   $interval=10         if ($interval<10);
   $retrycount=3        if (!defined($retrycount));
   $firstcalldelay=5    if ($firstcalldelay<5);
   $spooltag="t".time() if ($spooltag eq "");

   # 1. Step: the minimum firstcallin time is 10 seconds
   # 2. Step: put the entry in the processtimer control hash
   # 3. Step: init async process
   # 4. Step: write an entry in the eventspool table by base::eventspool
   my $control={spooltag       =>$spooltag,
                eventname      =>$name,
                eventparam     =>join(" ",@p),
                retryinterval  =>$interval,
                maxretry       =>$retrycount,
                failcount      =>0,
                unixcalltime   =>time(),
                lasttrytime    =>undef,
                firstcalldelay =>$firstcalldelay,
                createuser     =>$userid};
   if (!defined($self->{EventSpool}->{$spooltag}) ||
       ($redefine==1 && !defined($self->{EventSpool}->{$spooltag}->{run}))){
      $self->{EventSpool}->{$spooltag}=$control;
      return({exitcode=>0});
   }
   return({exitcode=>1,msg=>'event already running or not redefineable'});
}

sub DumpJobSpool
{
   my $self=shift;
   my $spooltag=shift;
 #  my $jobspool=getModuleObject($self->Config,"base::jobspool");
 #  if (defined($spooltag)){
 #     print STDERR Dumper($self->{EventSpool}->{$spooltag});
 #  }
 #  else{
 #     print STDERR Dumper($self->{EventSpool});
 #  }
}

sub rpcMultiCacheQuery
{
   my $self=shift;
   my $account=shift;
   my %res=();
   my $r;

   msg(DEBUG,"rpcMultiCacheQuery from $account");
   return({exitcode=>1,msg=>'noaccount'}) if ($account eq "");
   $r=$self->QueryCache("User",$account);
   if (defined($r) && $r->{exitcode}==0){
      $res{User}=$r->{state};
   }
   $r=$self->QueryCache("Menu");
   if (defined($r) && $r->{exitcode}==0){
      $res{Menu}=$r->{state};
   }
   $r=$self->QueryCache("Group");
   if (defined($r) && $r->{exitcode}==0){
      $res{Group}=$r->{state};
   }
   $r=$self->QueryCache("Mandator");
   if (defined($r) && $r->{exitcode}==0){
      $res{Mandator}=$r->{state};
   }
   $r=$self->QueryCache("IOMapper");
   if (defined($r) && $r->{exitcode}==0){
      $res{IOMapper}=$r->{state};
   }

   return({exitcode=>0,%res});
}


sub rpcCacheQuery
{
   my $self=shift;
   my $name=shift;
   my $subkey=shift;

   my $msg="rpcCacheQuery: name=$name";
   $msg.="subkey=$subkey" if ($subkey ne "");
   msg(DEBUG,$msg);
   return($self->QueryCache($name,$subkey));
}

sub loadEventRouterTable
{
   my $self=shift;
   eval('
my $er=getModuleObject($self->Config,"base::eventrouter");
$er->SetFilter({cistatusid=>\"4"});
$self->{EventRouterTable}=[$er->getHashList(qw(srceventtype srcmoduleobject srcsubclass dstevent controldelay controlmaxretry controlretryinterval fullname))];
');
   if ($@ ne ""){
      msg(ERROR,"loadEventRouterTable=$@");
   }
   else{
      #msg(DEBUG,"loadEventRouterTable new loaded");
      #msg(DEBUG,Dumper($self->{EventRouterTable}));
   }
}

sub rpcSendRemoteEvent
{
   my $self=shift;
   my $userid=shift;
   my $modulename=shift;
   my $operation=shift;
   my $identifiedBy=shift;
   my $submodule=shift;

   my $msg="rpcSendRemoteEvent: name=$modulename $submodule($operation) ".
           "$identifiedBy";
   msg(DEBUG,$msg);
   if ($modulename eq "base::eventrouter"){
      delete($self->{EventRouterTable});
   }
   if (!defined($self->{EventRouterTable})){
      $self->loadEventRouterTable();
   }
   if (ref($self->{EventRouterTable}) eq "ARRAY"){
      foreach my $r (@{$self->{EventRouterTable}}){
         if ($r->{srcmoduleobject} eq $modulename ||
             $r->{srcmoduleobject} eq "Any"){
            if ($r->{srcsubclass} eq "Any" ||
                $r->{srcsubclass} eq $submodule){
               if ($r->{srceventtype} eq "Any" ||
                   $r->{srceventtype} eq $operation){
                  if ($r->{dstevent} ne ""){
                     my $id=$self->rpcGetUniqueId->{id};
                     my $spooltag="rpcSendRemoteEvent.".
                                  $identifiedBy."-".$operation.
                                  "(".$modulename."-".$r->{dstevent}.")";
                     my $interval=60;
                     my $retrycount=5;
                     my $firstcalldelay=$r->{controldelay};
                     $firstcalldelay=2 if ($firstcalldelay<2);
                     my @eventparam;
                     if ($identifiedBy ne ""){
                        push(@eventparam,"id",$identifiedBy);
                     }
                     push(@eventparam,"op",$operation);
                     push(@eventparam,"mod",$modulename);
                     if ($submodule ne ""){
                        push(@eventparam,"sclass",$submodule);
                     }
                     if ($userid!=0){
                        push(@eventparam,"uid",$userid);
                     }
                     push(@eventparam,"eid",$id);
                     my $control={spooltag       =>$spooltag,
                                  eventname      =>$r->{dstevent},
                                  eventparam     =>\@eventparam,
                                  retryinterval  =>$r->{controlretryinterval},
                                  maxretry       =>$r->{controlmaxretry},
                                  failcount      =>0,
                                  unixcalltime   =>time(),
                                  lasttrytime    =>undef,
                                  firstcalldelay =>$firstcalldelay};
                     $self->{EventSpool}->{$spooltag}=$control;
                  }
               }
            }
         }
      }
   }
   return({exitcode=>0});
}

sub QueryCache
{
   my $self=shift;
   my $name=shift;
   my $subkey=shift;

   if (!defined($self->{CacheState})){
      my $id=$self->rpcGetUniqueId->{id};
      $self->{CacheState}={state=>$id,subkey=>{}};
   }
   my $ca=$self->{CacheState};
   if (!defined($name)){
      return({exitcode=>0,state=>$ca->{state}})
   }
   if (!defined($ca->{subkey}->{$name})){
      my $id=$self->rpcGetUniqueId->{id};
      $ca->{subkey}->{$name}={subkey=>{},state=>$id};
   }
   if (!defined($subkey)){
      return({exitcode=>0,state=>$ca->{subkey}->{$name}->{state}});
   }
   if (!defined($ca->{subkey}->{$name}->{subkey}->{$subkey})){
      my $id=$self->rpcGetUniqueId->{id};
      $ca->{subkey}->{$name}->{subkey}->{$subkey}={state=>$id};
   }
   return({exitcode=>0,
           state=>$ca->{subkey}->{$name}->{subkey}->{$subkey}->{state}});
}


sub rpcCacheInvalidate
{
   my $self=shift;
   my $name=shift;
   my $subkey=shift;

   msg(DEBUG,"rpcCacheInvalidate: name=$name subkey=$subkey");
   my $id=$self->rpcGetUniqueId->{id};

   if (!defined($subkey) && !defined($name)){
      delete($self->{CacheState});
   }
   if (!defined($subkey) && defined($name)){
      delete($self->{CacheState}->{subkey}->{$name});
   }
   if (defined($subkey) && defined($name)){
      delete($self->{CacheState}->{subkey}->{$name}->{subkey}->{$subkey});
   }
   return($self->rpcCacheQuery($name,$subkey));
}

sub resetEventController
{
   my $self=shift;
   my @resetmodules=grep(/[^\/]+\/event\/[^\/]+\.pm/,keys(%INC));
   foreach my $mod (@resetmodules){
      delete($INC{$mod});
   }
   $self->{EventController}=new kernel::EventController(
                                                        Config=>$self->{Config}
                                                       );
   $self->{EventController}->LoadEventHandler();
}

sub rpcResetEvents
{
   my $self=shift;
   $self->resetEventController();
   return({exitcode=>0});
}


sub rpcEventInfo
{
   my $self=shift;
   my $eventname=shift;

   my @methods=$self->{EventController}->getEventMethods($eventname);

   if ($#methods!=-1){
      my $timeout=$self->{EventController}->getMaxEventTimeout($eventname);
      my $evrec={
        name=>$eventname,
        timeout=>$timeout,
        methods=>\@methods,
      };
      return({event=>$evrec,exitcode=>0});
   }
   return({exitcode=>-1});
}




sub rpcGetUniqueId
{
   my $self=shift;
   my $n=shift;

   if (defined($self->{'PW5Server'})){
      if (exists($self->{'UniqueIdPool'}) && $#{$self->{'UniqueIdPool'}}!=-1){
         my $id=shift(@{$self->{'UniqueIdPool'}});
         return({id=>$id,exitcode=>0});
      }
      my $p=50;  # pool size
      my $res=$self->{'PW5Server'}->Call("rpcGetUniqueId",$p);
      my $id;
      if (!defined($res)){
         my $retry=15;
         while(!defined($res=$self->{'PW5Server'}->Call("rpcGetUniqueId",$p))){
            if (!defined($res)){
               sleep(1);
               last if ($retry--<=0);
            }
         }
      }
      if (defined($res) && $res->{exitcode}==0 &&
          ref($res->{id}) eq "ARRAY"){
         @{$self->{'UniqueIdPool'}}=@{$res->{id}};
         $id=shift(@{$self->{'UniqueIdPool'}});
      }
      if (defined($id) && $id ne ""){
         return({id=>$id,exitcode=>0});
      }
      return({exitcode=>9999,exitmsg=>"no primary server response"});
   }
   my $t=time();
   if (defined($n) && $n>1){     # at this point, the cached sequence technique
                                 # will be implemented
      my @id=();
      my $blk=0;
      $n=2000 if ($n>2000);
      msg(DEBUG,"rpcGetUniqueId: pool request %d",$n);
      for(my $c=0;$c<$n;$c++){
         if ($blk++>900){
            $blk=0;
            sleep(1);
            $t=time();
         }
         if ($t > ($self->{'UniqueId'}->{'timer'})){
            $self->{'UniqueId'}->{'counter'}=0;
            $self->{'UniqueId'}->{'timer'}=$t;
         }
         push(@id,sprintf('%d%04d',$t,$self->{'UniqueId'}->{'counter'}++));
      }
      return({id=>\@id,exitcode=>0});
   }

   msg(DEBUG,"rpcGetUniqueId: UniqueId=%d/%d time=%d",
             $self->{'UniqueId'}->{'counter'},
             $self->{'UniqueId'}->{'timer'},
             $t);
   if ($t > ($self->{'UniqueId'}->{'timer'})){
      $self->{'UniqueId'}->{'counter'}=0;
      $self->{'UniqueId'}->{'timer'}=$t;
   }
   return({id=>sprintf('%d%04d',$t,$self->{'UniqueId'}->{'counter'}++),
           exitcode=>0});
}

sub Config
{
   my ($self)=@_;

   return($W5V2::Config);
}

sub W5ServerConnect
{
   my $self=shift;

   if (!defined($W5V2::W5Server)){
      my %ClientParam;
      $ClientParam{'PeerAddr'}=$self->Config->Param("W5SERVERHOST");
      $ClientParam{'PeerPort'}=$self->Config->Param("W5SERVERPORT");
      $W5V2::W5Server=new RPC::Smart::Client(%ClientParam);
      $W5V2::W5Server->Connect();
   }
   $self->Cache->{W5Server}=$W5V2::W5Server;
   $W5V2::Query=new kernel::cgi({});

}

sub NotifyAdmin
{
   my $self=shift;
   my $subject=shift;
   my $text=shift;

   my @sendmailpath=qw(/usr/local/sbin/sendmail 
                       /sbin/sendmail 
                       /usr/sbin/sendmail 
                       /usr/lib/sendmail
                       /usr/lib/sbin/sendmail);
   my $sendmail=undef;
   foreach my $s (@sendmailpath){
      if (-x $s){
         $sendmail=$s;
         last;
      }
   }
   if (!defined($sendmail)){
      printf STDERR ("ERROR no sendmail found\n");
      exit(1);
   }

   my $user=$self->Config->Param("W5SERVERSERVICE");
   my $sitename=$self->Config->Param("SITENAME");
   if ($user eq ""){
      $user=$self->Config->Param("W5SERVERUSER");
   }
   if ($sitename ne ""){
      $sitename="W5Server: $sitename";
   }
   else{
      $sitename="W5Server";
   }
   $sitename=~s/["']//g;
   $user="root" if ($user eq "");
   my ($fh,$filename)=tempfile();
   if (defined($fh)){ 
      printf $fh ("cat << EOF | $sendmail -t\n");
      printf $fh ("To: %s\n",$user);
      printf $fh ("From: %s\n","\"$sitename\" <W5Server>");
      printf $fh ("Subject: %s\n",$subject);
      printf $fh ("Content-Type: text/plain; charset=\"iso-8859-1\"\n\n");
      print $fh ($text);
      print $fh "\nEOF\n";
      close($fh);
      system("sh $filename");
      unlink($filename);
   }
}


sub initAsyncEnv
{
   my $self=shift;
   my $label=shift;
   my $param=shift;
   my $method=shift;

   delete($self->{W5Server});
   delete($self->{W5ServerProcess});
   W5Server::CloseAllOpenFieldHandles();
   $self->W5ServerConnect();
   #######################################################################
   # STDERR Handling
   #
   $|=1;
   pipe(REDIRSTDERR,NEWSTDERR);
   my $pid=fork();
   if ($pid==0){
      my $tasks=$self->getTasksHash();  # this should be done in RPC::Server,
      %{$tasks}=();                     # but at this position, i didnt need
      $SIG{INT}='IGNORE';
      $SIG{INT}='DEFAULT';
      $SIG{HUP}='DEFAULT';
      $0.=" MONITOR";
      my @e;
      my $exitstate="unknown";
      my $emsg;
      my @output;
      my $ppid=POSIX::getppid();
      my $evname="event $label ";
      my %oldtaskenv=%{$self->{taskenv}};
      while(1){
         if (defined($self->{taskenv}) && defined($self->{taskenv}->{timeout})){
            if ($self->{taskenv}->{start}+$self->{taskenv}->{timeout}<time()){
               my $msg="ERROR: killed $evname at pid=$ppid by timeout ".
                       "$self->{taskenv}->{timeout}sec by signal TERM\n";
               kill(15,$ppid);
               sleep(1);
               sleep(3)      if (kill(0,$ppid));
               if (kill(0,$ppid)){
                  kill(9,$ppid);
                  $msg="ERROR: force killed event at pid=$ppid by timeout ".
                       "$self->{taskenv}->{timeout}sec by signal KILL\n";
                  sleep(3);
                  if (kill(0,$ppid)){
                     $msg.="ERROR: shit - force kill haven't kill pid $ppid\n";
                     $msg.="ERROR: ... this is not good !!!\n";
                  }
               }
               push(@e,$msg);
            }
         }
         my $s=new IO::Select();
         $s->add(\*REDIRSTDERR);
         my @ready=$s->can_read(1);
         if ($#ready!=-1){
            $_=<REDIRSTDERR>;
            push(@output,$_);
            print STDERR "STDERR($ppid):".$_;
            if (!($_=~m/^INFO:/ ||
                  $_=~m/^DEBUG:/)){
               push(@e,$_);
            }
         }
        # else{
        #    sleep(1);
        # }
        if ((my $sysexitcode=waitpid($ppid,WNOHANG))>0){
           my $sig=$sysexitcode&8;
           $exitstate="SIGNAL".$sig;
           last;
        }
        last if (!kill(0,$ppid));
      }
      $SIG{INT}='DEFAULT';
      $SIG{HUP}='DEFAULT';
      $SIG{CHLD}='DEFAULT';
      $SIG{ALRM}='DEFAULT';
      $SIG{USR1}='DEFAULT';
      $SIG{TERM}='DEFAULT';
      $SIG{PIPE}='DEFAULT';
      $SIG{WARN}='DEFAULT';
      my %taskenv=%{$self->{taskenv}};
      my $ipcval=$taskenv{ipc}->fetch();
      delete($taskenv{ipc}); 
      my $VAR1=undef;
      eval($ipcval);
      my $ipcresult;
      if ($@ eq ""){
         $ipcresult=$VAR1;
      }
      else{
         my $res=$@;
         $emsg="ERROR: eval error on IPC Result";
         push(@e,$emsg);
         push(@e,msg(ERROR,$res));
         push(@e,"ipcval=$ipcval");
      }
      if (!defined($ipcresult)){
         $emsg=msg(ERROR,"$evname maybe crashed? - no valid ipc results");
         push(@e,$emsg);
         push(@e,msg(ERROR,Dumper(\%taskenv)));
         push(@e,msg(ERROR,"old=".Dumper(\%oldtaskenv)));
         push(@e,"ipcval=$ipcval");
      }
      if ($#e!=-1){
         push(@e,"\n\n","call of '$label' with method '$method'\n",
                      Dumper($param)."\n");
         if ($#output!=-1){
            if ($#output>10){
               splice(@output,0,$#output-10);
            }
            push(@e,"\n\n","last 10 lines output dump:\n",
                           "==========================\n",@output);
         }
         $self->NotifyAdmin("ERROR: messages while processing $evname messages",
                            join("",@e));
      }
      if ($self->Config->Param("W5BaseOperationMode") eq "readonly"){
         POSIX::_exit(0);
      }
      my $joblog=getModuleObject($self->Config,"base::joblog");
      if (defined($ipcresult->{handlerresult}) &&
          ref($ipcresult->{handlerresult}) eq "ARRAY"){
         foreach my $m (@{$ipcresult->{handlerresult}}){
            if (defined($m->{jobid}) && $m->{jobid} ne ""){
               my $exitcode;
               if (defined($m->{exitcode})){
                  $exitcode=$m->{exitcode};
                  $exitstate="retry" if ($exitcode<0);
                  $exitstate="fail" if ($exitcode>0);
                  $exitstate="ok"   if (defined($exitcode) && $exitcode==0);
               }
               if (defined($m->{msg})){
                  $emsg=$m->{msg};
               }
               if (defined($m->{exitmsg})){
                  $emsg=$m->{exitmsg};
               }
               $emsg="" if (!defined($emsg));
               $joblog->ValidatedUpdateRecord({id=>$m->{jobid}},
                                             {exitcode=>$exitcode,
                                              exitmsg=>$emsg,
                                              exitstate=>$exitstate},
                                             {id=>\$m->{jobid}});
            }
         }
      }
      $joblog->SetFilter({pid=>\$ppid});
      $joblog->SetCurrentView(qw(ALL));
      $joblog->ForeachFilteredRecord(sub{
                            if (!defined($_->{exitstate}) ||
                                $_->{exitstate} eq ""){
                               $joblog->ValidatedUpdateRecord($_,
                                    {exitstate=>$exitstate},{id=>\$_->{id}});
                            }
                            });
      msg(DEBUG,"controll process for pid=%d end",$ppid);
      msg(DEBUG,"pid=%d ends width errors",$ppid) if ($#e!=-1);
      POSIX::_exit(0);
   }
   open(STDERR, ">&NEWSTDERR");
   #######################################################################
   #$self->ValidateGroupCache(); # mal ein Test, ob es auch ohne geht
}


sub sig_hup
{
   my $self=shift;

   if ($W5V2::Debug){
      $self->server_close;
      exit();
   }
   my $bk=$self->SUPER::sig_hup();

   delete($ENV{BOUND_SOCKETS});
   return($bk);
}

sub ProcessSpoolEvent
{
   my $self = shift;
   my $control = shift;
   my $tasks=$self->getTasksHash();
   return() if (keys(%$tasks)>40);

   msg(DEBUG,"Run spooled event: %s",$control->{spooltag});
   if (defined($control->{run})){
     # msg(DEBUG,"name=%s d=%s",$control->{eventname},Dumper($control->{run}));
      return();
   }
   $control->{lasttrytime}=time();
   my @param=$control->{eventparam};
   @param=@{$control->{eventparam}} if (ref($control->{eventparam}) eq "ARRAY");
   $control->{run}=$self->rpcCallSerialEvent($control->{eventname},@param);
}

sub run_dequeue
{
   my $self = shift;

   if (exists($self->{'ServerGoesDown'})){
      if ($self->{'ServerGoesDown'}<=0 || $self->runningTasks()==0){
         if (exists($self->{'ServerHalt'})){
            $self->server_close();
         }
         else{
            $self->sig_hup();
         }
      }
      $self->{ServerGoesDown}--;
      msg(INFO,"$self->{ServerGoesDown} seconds to shutdown");
   }
   if ($self->{debug}){   # if terminal is closed, process goes down
      if (! -t STDOUT){
         sleep(1);
         $self->server_close(); 
      }
   }
   
   my $bk=$self->{EventController}->ProcessTimer();
   if (time() % 120 == 0){ # check only ever 120s
      $self->CheckW5ServerProcess();
   }
   if (defined($self->{EventSpool}) && keys(%{$self->{EventSpool}})){
      msg(DEBUG,"EventSpool: %s",join(",",keys(%{$self->{EventSpool}})));
      foreach my $control (values(%{$self->{EventSpool}})){
         if (defined($control->{run}) && $control->{run}->{nohandler}==1){
            delete($self->{EventSpool}->{$control->{spooltag}}); 
         }
         if (defined($control->{run}) && defined($control->{run}->{AsyncID})){
            my $st=$self->rpcAsyncState($control->{run}->{AsyncID});
            if ($st->{exitcode}==1){
               if ($st->{invalidAsyncID}){
                  msg(WARN,"EventSpool: cleanup old run entry");
                  delete($control->{run});
               }
            }
            if ($st->{exitcode}==0){
               my $exitcode;
               if (exists($st->{process}->{ipc}) &&
                   ref($st->{process}->{ipc}->{handlerresult}) eq "ARRAY"){
                  foreach my $hres (@{$st->{process}->{ipc}->{handlerresult}}){
                     if ($exitcode<=$hres->{exitcode}){
                        $exitcode=$hres->{exitcode};
                     }
                  }
               }
               $exitcode=-1 if (!defined($exitcode));
               if (defined($exitcode)){
                  my $e=$exitcode;
                  if ($e==0){
                     delete($self->{EventSpool}->{$control->{spooltag}});
                  }
                  elsif ($e<0){
                     $control->{failcount}--;
                     $control->{failcount}=0 if ($control->{failcount}<0);
                  }
                  else{
                     delete($self->{EventSpool}->{$control->{spooltag}}
                            ->{run});
                  }
               }
            }
            #delete($self->{EventSpool}->{$control->{spooltag}}); 
         }
         else{
            if (!defined($control->{lasttrytime})){
               if ($control->{unixcalltime}+$control->{firstcalldelay}<time()){
                  $self->ProcessSpoolEvent($control);
               }
            }
            else{
               if ($control->{lasttrytime}+$control->{retryinterval}<time()){
                  if ($control->{failcount}>=$control->{maxretry}){
                     # event failed - notify admin 
                     delete($self->{EventSpool}->{$control->{spooltag}});
                  }
                  else{
                     $control->{failcount}++;
                     $self->ProcessSpoolEvent($control);
                  }
               }
            } 
         } 
      }
   }
   return($self->SUPER::run_dequeue(@_));
}

sub configure_hook
{
   my $self=shift;

   $self->max_async(320);
   $self->{'UniqueId'}={'counter'=>0,timer=>time()};
   $self->{'CacheState'}={};
   if ($W5V2::Debug==1){
      $self->{'debug'}=1;
   }
   $self->{Config}=$W5V2::Config;

   my $dummyapp=new kernel::App(Config=>$self->{Config});
   if (!defined($W5V2::Translation{$dummyapp})){
      $W5V2::Translation{$dummyapp}={self=>$dummyapp,tab=>{}};
   }
   $W5V2::Translation=$W5V2::Translation{$dummyapp};

   msg(DEBUG,"debug=%s",$self->{'debug'});
   @ARGV[0]="W5Server";


   my $primh=$self->{Config}->Param("W5PRIMARYSERVERHOST");
   my $primp=$self->{Config}->Param("W5PRIMARYSERVERPORT");
   if ($primh ne "" && $primp ne ""){
      my %ClientParam;
      $ClientParam{'PeerAddr'}=$primh;
      $ClientParam{'PeerPort'}=$primp;
      $self->{PW5Server}=new RPC::Smart::Client(%ClientParam);
      $self->{PW5Server}->Connect();
   }

   $self->resetEventController();
   return(1);
}

sub post_configure_hook
{
   my $self=shift;

   my $statefile=$self->getOfflineStateFile();
   if (-f $statefile){
      if (open(F,"<$statefile")){
         my $d=join("",<F>);
         eval($d);
         msg(DEBUG,"loaded %d events from statefile",
                    keys(%{$self->{EventSpool}}));
         close(F);
         unlink($statefile);
      }
   }
}


sub pre_loop_hook
{
   my $self=shift;

   my @ent=getpwuid($>);
   my $home=$ent[7];
   $ENV{HOME}=$home if (-d $home);

   $SIG{USR1}=sub{          # soft restart
      #delete($self->{ServerHalt});
      #$self->{ServerGoesDown}=15;
      #$self->sendSignalToAllRunningProcesses(10);
      msg(INFO,"Soft Restart disabled - USR1 ignored");
   };
   $SIG{USR2}=sub{          # soft shutdown
      $self->{ServerHalt}=1;
      $self->{ServerGoesDown}=15;
      $self->sendSignalToAllRunningProcesses(10);
      msg(INFO,"Soft Shutdown handler initiated");
   };

   $self->RunScheduler();
   return(1);
}

sub RunScheduler
{
   my $self=shift;

   my $W5ServerMode=lc($self->{Config}->Param("W5SERVERMODE"));

   if ($W5ServerMode eq "hotstandby"){
      $self->{W5Server}={};
   }
   else{
      $self->LoadSubObjs("W5Server","W5Server");
      foreach my $server (keys(%{$self->{W5Server}})){
         #next if (!($server=~m/Reporter/));
         $self->StartW5ServerProcess($server);
      }
   }

   #########################################################################
}

sub StartW5ServerProcess
{
   my $self=shift;
   my $server=shift;

   my $srv=$self->{W5Server}->{$server};
   my $srvsub;
   my $srvcode=<<EOF;
      my \$tasks=\$self->getTasksHash();  # this should be done in RPC::Server,
      \%{\$tasks}=();                     # but at this position, i didnt need
                                          # a module update
      W5Server::CloseAllOpenFieldHandles();     # needed on restart!

      W5Server::MakeAllDBHsForkSafe();

      \$0="W5Sserver-".\$server;
      my \$orgpid=\$\$;
      sub start{
          \$srv->start();
      }
      sub process{
          \$srv->process();
      }
      sub reload{
          \$self->NotifyAdmin("$server USR2 - reload  received ".
                              "pid=\$orgpid:\$\$ \$0","USR2");
          \$srv->reload();
      }
      sub hup{
          if (\$W5V2::Debug){
             exit();
          }
          \$self->NotifyAdmin("$server hup received ".
                              "pid=\$orgpid:\$\$ \$0","HUP");
          \$srv->reload();
      }
      sub shutdown{
          #\$self->NotifyAdmin(
          #    "\$server int (normal shutdown) pid=\$orgpid:\$\$ \$0","int");
          msg(DEBUG,"Server \$srv normal shutdown");
          \$srv->end();
      }
      foreach my \$sig (keys(\%SIG)){
          if (\$sig eq "HUP"){
             if (\$W5V2::Debug){          # in debug mode, the terminal creates
                \$SIG{\$sig}=\\&shutdown; # a HUP signal on close of term, soo
             }                            # it needs to be handle as shutdown
             else{
                \$SIG{\$sig}=\\&hup;
             }
             next;
          }
          if (\$sig eq "__DIE__" || \$sig eq "__WARN__"){
             \$SIG{\$sig}='default';
             next;
          }
          if (\$sig eq "INT"){
             \$SIG{INT}=\\&shutdown;
             next;
          }
          if (\$sig eq "USR2"){   # USR2 works always for reload - even in
             \$SIG{\$sig}=\\&reload; # debug mode
             next;
          }
          if (\$sig eq "WINCH"){
             \$SIG{\$sig}='IGNORE';
             next;
          }
          if (\$sig eq "CHLD" || \$sig eq "CLD"){
             \$SIG{\$sig}='IGNORE';
             next;
          }
          if (\$sig eq "PIPE" | \$sig eq "SEGV"){
             \$SIG{\$sig}=sub{
                 \$self->NotifyAdmin(
                    "\$server \$sig erhalten pid=\$orgpid:\$\$ \$0",\$sig);
                 exit(1);  # any Pipe is broken
             };
             next;
          }
          if (\$sig eq "USR1"){
             \$SIG{\$sig}=sub{
                 #\$self->NotifyAdmin(
                 #  "\$server usr1=NormalShutdown erhalten pid=\$orgpid:\$\$ \$0","usr1");
                \$srv->{ServerGoesDown}=1;
             };
             next;
          }
          #msg(DEBUG,"installing dummy signal handler for \$sig");
          \$SIG{\$sig}=sub{
              \$self->NotifyAdmin("\$server \$sig erhalten pid=\$orgpid:\$\$ \$0",\$sig);
          };
 
      }
      eval('
         \$self->W5ServerConnect();
         start(); 
         process(); 
      ');
      if (\$\$ eq \$orgpid){ # error an we are in original server
         if (\$@ ne ""){ # error an we are in original server
            \$self->NotifyAdmin("$server crash pid=\$\$ \$0","\$@");
         }
      }
      else{
         if (\$@ ne ""){ 
            print STDERR \$@;
            exit(1);
         }
      }
EOF
   eval("\$srvsub=sub { $srvcode return({exitcode=>0}); }");

   my $sched=$self->async($srvsub,name=>$server);
   $self->{W5ServerProcess}->{$server}=$sched;
}

sub CheckW5ServerProcess
{
   my $self=shift;
   foreach my $server (keys(%{$self->{W5Server}})){
      if (exists($self->{W5ServerProcess}->{$server})){ # is schon mal gelaufen!
         my $pid=$self->{W5ServerProcess}->{$server}->{AsyncID};
         if (!kill(0,$pid)){
            msg(ERROR,"W5Server $server was crashed - now restarting");
            $self->NotifyAdmin("W5Server $server unexpected termination",
                               "The W5Server $server has been terminated ".
                               "unexpected. Now trying to restart.\n\n".
                               "Sorry, but no further informations available ".
                               "from this point of view.");
            $self->StartW5ServerProcess($server);
         }
      }
   }
}


sub getOfflineStateFile
{
   my $self=shift;
   my $statefile=$self->{server}->{pid_file};
   $statefile=~s/\.pid$/\.state/;
   return($statefile);
}

sub sendSignalToAllRunningProcesses
{
   my $self=shift;
   my $signal=shift;
   my $n=0;

#  Das ist nicht mehr notwendig, da die W5Serverprozesse Teil des TaskHashes
#  sind.
#
#   foreach my $server (keys(%{$self->{W5Server}})){  # sending INT to current
#      my $pid=$self->{W5ServerProcess}->{$server}->{AsyncID}; # spare w5servers
#      msg(DEBUG,"send Signal($signal) from %s to %s at %s",
#                getpid(),$server,$pid);
#      if (kill($signal,$pid)){
#         $n++;
#      }
#   }
#   sleep(1);
   my $tasks=$self->getTasksHash();
   #print STDERR "sendSignalToAllRunningProcesses:".Dumper($tasks);
   foreach my $pid ($self->runningTasks()){
      msg(DEBUG,"send Signal($signal) to event at pid %s from '$0'",$pid);
      if (kill($signal,$pid)){
         $n++;
      }
   }
   return($n);
}


sub runningTasks
{
   my $self=shift;
   my @l;

   my $tasks=$self->getTasksHash();
   foreach my $pid (keys(%{$tasks})){  
      if (!exists($tasks->{$pid}->{exitcode})){
         push(@l,$pid);
      }
   }
   if (wantarray()){
      return(@l);
   }
   return($#l+1);
}

sub pre_server_close_hook
{
   my $self=shift;

   #$self->DumpJobSpool();
   my $statefile=$self->getOfflineStateFile();
   msg(DEBUG,"server shutdown initiated in $$ ($0)");
   $self->sendSignalToAllRunningProcesses(2);
   if (defined($self->{EventSpool}) && keys(%{$self->{EventSpool}}) &&
       $statefile ne ""){
      msg(DEBUG,"try to dump eventspool to %s",$statefile);
      if (open(F,">$statefile")){
         print F Data::Dumper->Dump([$self->{EventSpool}], 
                                    ['$self->{EventSpool}']);
         msg(DEBUG,"dump eventspool ok");
         close(F);
      }
   }
   CloseAllOpenFieldHandles();
   msg(DEBUG,"server is down");
   return($self->SUPER::pre_server_close_hook());
}

sub CloseAllOpenFieldHandles
{
   for(my $c=3;$c<254;$c++){  # ensure, that all filehandles are closed
      POSIX::close($c);
   }
   $W5V2::W5Server=undef;
}

sub MakeAllDBHsForkSafe {
   my %drivers = DBI->installed_drivers;
   foreach my $drh (values %drivers) {
      foreach my $dbh (@{$drh->{ChildHandles}}){    
         msg(DEBUG,"set $dbh in $drh to InactiveDestroy=1 in $0");
     #    $dbh->{InactiveDestroy}=1; test hv: 09.05.
         #$dbh->{mysql_auto_reconnect}=1;
      }
   }
   my %drivers = DBI->installed_drivers;   # kill Cache entries
   foreach my $drh (values %drivers) {
      if (ref($drh->{CachedKids}) eq "HASH"){
         %{$drh->{CachedKids}}=();
      }
   }
}

#######################################################################
package main;
use vars qw($opt_v $opt_h $opt_c $configname);
use Getopt::Long;
use Net::Server::Daemonize qw(daemonize);
use kernel;
use kernel::config;
$ENV{PATH}="/usr/bin:/bin:/usr/contrib/bin:/usr/sbin:/sbin:".
           "/usr/local/bin:/usr/local/sbin:/opt/openssh/bin:".
           "/opt/ssh/bin/usr/local/ssh/bin";
my @ARGV_bak=@ARGV;
exit(1) if (!GetOptions('verbose'=>\$opt_v,
                        'debug'=>\$opt_v,
                        'help'=>\$opt_h,
                        'config=s'=>\$opt_c));
if ($opt_v){
   $W5V2::Debug=1;
}
else{
   $W5V2::Debug=0;
}
msg(DEBUG,"W5Server exec param: %s",join(" ",@ARGV_bak));

if (defined($opt_h)){
   help();
   exit(1);
}
if ($opt_c eq ""){
   $opt_c="w5server";
}
$configname=$opt_c;

#######################################################################
# ENV Init $W5V2::*
if (!defined($W5V2::INSTDIR)){
   if (defined(&{FindBin::again})){
      FindBin::again();
      $W5V2::INSTDIR="$FindBin::Bin/..";
   }
}
$W5V2::INSTDIR="/opt/w5base" if (!defined($W5V2::INSTDIR));
my @w5instpath;
if ($ENV{W5BASEINSTDIR} ne ""){
   @w5instpath=split(/:/,$ENV{W5BASEINSTDIR});
   $W5V2::INSTDIR=shift(@w5instpath);
   $W5V2::INSTPATH=\@w5instpath;
}
foreach my $path (map({$_."/mod",$_."/lib"} @{W5BaseInstPath()})){
   my $qpath=quotemeta($path);
   unshift(@INC,$path) if (!grep(/^$qpath$/,@INC));
}
#######################################################################






my %ServerParam=();
my $curconfig=new kernel::config();

if (!$curconfig->readconfig("$FindBin::Bin/..",$configname)){
   msg(ERROR,"can't read configfile '%s'",$configname);
   exit(1);
}

if ($ENV{REMOTE_USER} eq ""){
   if ($ENV{USER} ne ""){
      $ENV{REMOTE_USER}="system/$ENV{USER}";
   }
   else{
      $ENV{REMOTE_USER}="system/unknown";
   }
   $ENV{REAL_REMOTE_USER}="system/W5Server";
}


{
   my $port=$curconfig->Param("W5SERVERPORT");
   $port=4711 if ($port eq "");
   msg(DEBUG,"W5ServerPort=%s",$port);
   $ServerParam{'port'}=$port;
   my $allow=$curconfig->Param("W5SERVERALLOW");
   $allow="^127\\.0\\.0\\.1\$" if ($allow eq "127.0.0.1");
   $ServerParam{'allow'}=$allow;
   my $user=$curconfig->Param("W5SERVERUSER");
   $user="nobody" if ($user eq "");
   $ServerParam{'user'}=$user;
   my $group=$curconfig->Param("W5SERVERGROUP");
   $group="nobody" if ($group eq "");
   $ServerParam{'group'}=$group;
}

my $statedir=$curconfig->Param("W5SERVERSTATE");
if (! -d $statedir || $statedir eq ""){
   msg(ERROR,"can't access statedir '%s'",$statedir);
   exit(1);
}
$statedir.="/" if (!($statedir=~m/^\/$/));

{
   my $pidfile="${statedir}W5Server.${configname}.pid";
   $ServerParam{'pid_file'}=$pidfile;
   msg(DEBUG,"W5ServerPidFile=%s",$pidfile);
   if (-f $pidfile){
      msg(ERROR,"pidfile '%s' already exists",$pidfile);
      exit(1);
   }
}

$ServerParam{'no_close_by_child'}=1;

if ($W5V2::Debug==0){
   $ServerParam{'setsid'}=1;
   {
      my $logfile="${statedir}W5Server.${configname}.log";
      $ServerParam{'log_file'}=$logfile;
   }
   my $logTarget=$curconfig->Param("LogTarget");
   if ($logTarget ne ""){
      if ($logTarget=~m/^\//){  # LogTarget on W5Server only useable for files
         $logTarget=~s/\%f/NetW5Server/g;
         $ServerParam{'log_file'}=$logTarget;
      }
   }
   #printf STDERR ("W5ServerLogFile:%s\n",$ServerParam{'log_file'});
}
else{
   $ServerParam{'debug'}=1;
}
$W5V2::Config=$curconfig;
$W5V2::OperationContext="W5Server";
$W5V2::HistoryComments=undef;
@ARGV=@ARGV_bak;
#$0="W5Server";  # brings problems while HUP
W5Server->run(%ServerParam);


sub help
{
   printf STDERR ("Usage: W5Server [-d] -c {config} [-v]\n");
   printf STDERR ("\n");
   printf STDERR (" -c sets the name of the config (default:w5server.conf)\n");
   printf STDERR (" -v activates verbose mode\n");
   printf STDERR (" -d starts the W5Server in debug mode (not as background!)\n");
   printf STDERR ("\n");
}



